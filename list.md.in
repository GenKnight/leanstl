# Doubly Linked List: `list<T>`

![](list-tut.png)

## list00: data structure

![node](listnode.png)

Doubly linked list:
![list](list.png)

list00.cc:
@ib list00.cc "namespace leanstl"

Object sizes on 64-bit Linux.

```
sizeof void*:           8
sizeof size_t:          8
sizeof list_node_base: 16
sizeof list:           24

T = int
     sizeof T:          4
     sizeof list_node: 24

T = std::string
     sizeof T:          8
     sizeof list_node: 24

T = std::vector<int>
     sizeof T:         24
     sizeof list_node: 40
```

Object sizes on 32-bit Linux.

```
sizeof void*:           4
sizeof size_t:          4
sizeof list_node_base:  8
sizeof list:           12

T = int
     sizeof T:          4
     sizeof list_node: 12

T = std::string
     sizeof T:          4
     sizeof list_node: 12

T = std::vector<int>
     sizeof T:         12
     sizeof list_node: 20
```

## list01: destructor

@ib list01.cc "template <typename T>"

### Mistake: use-after-free

list01err0.cc
@ib list01err0.cc "  ~list()"

@ib list01err0.cc "int main()"
```
$ code/bin/list01err0
front=43
Segmentation fault (core dumped)

$ gdb code/bin/list01err0 core
Core was generated by `code/bin/list01err0'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x0000000000400847 in leanstl::list<int>::~list (this=0x7ffd3dff5da0) at list01err0.cc:30
30          for (list_node_base* n = head_.next; n != &head_; n = n->next)

(gdb) p n
$1 = (leanstl::list_node_base *) 0x0

(gdb) p *this
$2 = {
  head_ = {
    next = 0x181e010,
    prev = 0x181e010
  },
  size_ = 1
}

(gdb) p *head_.next
$3 = {
  next = 0x0,
  prev = 0x7ffd3dff5da0
}
```

Some clever person finds a way to avoid coredump, by deleting from tail to head.

list01err0hack.cc
@ib list01err0hack.cc "  ~list()"

Valgrind
```
==56399== Invalid read of size 8
==56399==    at 0x400847: leanstl::list<int>::~list() (list01err0.cc:30)
==56399==    by 0x4007C6: main (list01err0.cc:75)
==56399==  Address 0x5a02040 is 0 bytes inside a block of size 24 free'd
==56399==    at 0x4C2A360: operator delete(void*) (vg_replace_malloc.c:507)
==56399==    by 0x400842: leanstl::list<int>::~list() (list01err0.cc:32)
==56399==    by 0x4007C6: main (list01err0.cc:75)
```

Address sanitizer

```
$ bin/list01err0asan
front=43
=================================================================
==57074==ERROR: AddressSanitizer: heap-use-after-free on address 0x60300000efe0 at pc 0x400de5 bp 0x7ffe324e9ee0 sp 0x7ffe324e9ed8
READ of size 8 at 0x60300000efe0 thread T0
    #0 0x400de4 in leanstl::list<int>::~list() code/list01err0.cc:30
    #1 0x400c3f in main code/list01err0.cc:73
    #2 0x7f19eb9f7b44 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21b44)
    #3 0x400a78 (code/bin/list01err0asan+0x400a78)

0x60300000efe0 is located 0 bytes inside of 24-byte region [0x60300000efe0,0x60300000eff8)
freed by thread T0 here:
    #0 0x7f19ec5f8477 in operator delete(void*) (/usr/lib/x86_64-linux-gnu/libasan.so.1+0x55477)
    #1 0x400dc3 in leanstl::list<int>::~list() code/list01err0.cc:32
    #2 0x400c3f in main code/list01err0.cc:73
    #3 0x7f19eb9f7b44 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21b44)

previously allocated by thread T0 here:
    #0 0x7f19ec5f7fff in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.1+0x54fff)
    #1 0x400e34 in leanstl::list<int>::push_front(int) code/list01err0.cc:41
    #2 0x400bda in main code/list01err0.cc:72
    #3 0x7f19eb9f7b44 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21b44)

SUMMARY: AddressSanitizer: heap-use-after-free code/list01err0.cc:30 leanstl::list<int>::~list()
```

### Mistake: delete pointer of `list_node_base*`

list01err1.cc
@ib list01err1.cc "  ~list()"

TODO: quote standard on this undefined behavior.

Valgrind
```
==56456== HEAP SUMMARY:
==56456==     in use at exit: 30 bytes in 1 blocks
==56456==   total heap usage: 4 allocs, 3 frees, 102 bytes allocated
==56456==
==56456== LEAK SUMMARY:
==56456==    definitely lost: 30 bytes in 1 blocks
```

Address sanitizer (clang 3.9.0)

```
==57346==ERROR: LeakSanitizer: detected memory leaks

Direct leak of 30 byte(s) in 1 object(s) allocated from:
    #0 0x4e7e7b  (code/bin/list01err1asan+0x4e7e7b)
    #1 0x7fa4984c1e98  (/usr/lib/x86_64-linux-gnu/libstdc++.so.6+0xbee98)

SUMMARY: AddressSanitizer: 30 byte(s) leaked in 1 allocation(s).
```

Double mistake:

```cpp
  ~list()
  {
    // DOUBLY WRONG
    for (list_node_base* n = head_.next; n != &head_; n = n->next)
    {
      delete n;
    }
  }
```
Execrise: try memory checker with this double error.

### list01alt: `list_node_base` with `protected` destructor

@i list01alt.cc 11-39,68-70

TODO: Why not virtual dtor?

Site note: GCC [Bug 54812](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=54812)

```cpp
struct Base
{
 private:
  ~Base() = default;
};

int main()
{
  Base* p = new Base;
  delete p;
}
```

## list02: iterator

list02.cc:
@i list02.cc 17-20,40-58,84-84

### list02const: `const_iterator`

list02const.cc:
@ib list02const.cc "  class const_iterator"

CRTP ?

## list03: copy control
list03.cc:

@i list03.cc 18-26,37-55,98-111,117-159

### Mistake

@ib list03err.cc "  list(const list& rhs)"

Composition vs. inheriance

@ib list04.cc "class list_base"
@i list04.cc 45-50,61-69

## list04: more constructors

@i list04.cc 72-83
@ib list04.cc "  struct list_node"

### Mistake

@ib list04err.cc "  struct list_node"

### InputIterator vs. Integer

@i list04more.cc 78-85,189-201

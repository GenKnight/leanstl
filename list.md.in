# Doubly Linked List: `list<T>`

![](list-tut.png)

## Data Structure

struct `list_node_base` and `list_node<T>`

```cpp
struct list_node_base
{
  list_node_base* next;
  list_node_base* prev;
};

template <typename T>
struct list_node : list_node_base
{
  T value_;
};
```

class template `list<T>`

@i list00.cc 16-25,32-35

![node](listnode.png)

Doubly linked list:
![list](list.png)

## list00: object sizes

list00.cc:
@i list00.cc 7-37

Object sizes on 64-bit Linux.

```
sizeof void*:           8
sizeof size_t:          8
sizeof list_node_base: 16
sizeof list:           24

T = int
     sizeof T:          4
     sizeof list_node: 24

T = std::string
     sizeof T:          8
     sizeof list_node: 24

T = std::vector<int>
     sizeof T:         24
     sizeof list_node: 40
```

Object sizes on 32-bit Linux.

```
sizeof void*:           4
sizeof size_t:          4
sizeof list_node_base:  8
sizeof list:           12

T = int
     sizeof T:          4
     sizeof list_node: 12

T = std::string
     sizeof T:          4
     sizeof list_node: 12

T = std::vector<int>
     sizeof T:         12
     sizeof list_node: 20
```

### list00a: `typedef`s

TODO

### list00b: accessors

TODO

## list01: `push_front`

@i list01.cc 17-65

### Mistake: use-after-free

list01err0.cc
@i list01err0.cc 27-34

@i list01err0.cc 69-74
```
$ tutorial/bin/list01err0
front=43
Segmentation fault (core dumped)

$ gdb tutorial/bin/list01err0 core
Core was generated by `tutorial/bin/list01err0'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x0000000000400847 in leanstl::list<int>::~list (this=0x7ffd3dff5da0) at list01err0.cc:30
30          for (list_node_base* n = head_.next; n != &head_; n = n->next)

(gdb) p n
$1 = (leanstl::list_node_base *) 0x0

(gdb) p *this
$2 = {
  head_ = {
    next = 0x181e010,
    prev = 0x181e010
  },
  size_ = 1
}

(gdb) p *head_.next
$3 = {
  next = 0x0,
  prev = 0x7ffd3dff5da0
}
```

Some clever person finds a way to avoid coredump, by deleting from tail to head.

list01err0a.cc
@i list01err0a.cc 27-34

Valgrind
```
==56399== Invalid read of size 8
==56399==    at 0x400847: leanstl::list<int>::~list() (list01err0.cc:30)
==56399==    by 0x4007C6: main (list01err0.cc:75)
==56399==  Address 0x5a02040 is 0 bytes inside a block of size 24 free'd
==56399==    at 0x4C2A360: operator delete(void*) (vg_replace_malloc.c:507)
==56399==    by 0x400842: leanstl::list<int>::~list() (list01err0.cc:32)
==56399==    by 0x4007C6: main (list01err0.cc:75)
```

Address sanitizer

```
$ bin/list01err0asan
front=43
=================================================================
==57074==ERROR: AddressSanitizer: heap-use-after-free on address 0x60300000efe0 at pc 0x400de5 bp 0x7ffe324e9ee0 sp 0x7ffe324e9ed8
READ of size 8 at 0x60300000efe0 thread T0
    #0 0x400de4 in leanstl::list<int>::~list() /home/schen/leanstl/tutorial/list01err0.cc:30
    #1 0x400c3f in main /home/schen/leanstl/tutorial/list01err0.cc:73
    #2 0x7f19eb9f7b44 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21b44)
    #3 0x400a78 (/home/schen/leanstl/tutorial/bin/list01err0asan+0x400a78)

0x60300000efe0 is located 0 bytes inside of 24-byte region [0x60300000efe0,0x60300000eff8)
freed by thread T0 here:
    #0 0x7f19ec5f8477 in operator delete(void*) (/usr/lib/x86_64-linux-gnu/libasan.so.1+0x55477)
    #1 0x400dc3 in leanstl::list<int>::~list() /home/schen/leanstl/tutorial/list01err0.cc:32
    #2 0x400c3f in main /home/schen/leanstl/tutorial/list01err0.cc:73
    #3 0x7f19eb9f7b44 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21b44)

previously allocated by thread T0 here:
    #0 0x7f19ec5f7fff in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.1+0x54fff)
    #1 0x400e34 in leanstl::list<int>::push_front(int) /home/schen/leanstl/tutorial/list01err0.cc:41
    #2 0x400bda in main /home/schen/leanstl/tutorial/list01err0.cc:72
    #3 0x7f19eb9f7b44 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21b44)

SUMMARY: AddressSanitizer: heap-use-after-free /home/schen/leanstl/tutorial/list01err0.cc:30 leanstl::list<int>::~list()
```

### Mistake: delete pointer of `list_node_base*`

list01err1.cc
@i list01err1.cc 27-36

TODO: quote standard on this undefined behavior.

Valgrind
```
==56456== HEAP SUMMARY:
==56456==     in use at exit: 30 bytes in 1 blocks
==56456==   total heap usage: 4 allocs, 3 frees, 102 bytes allocated
==56456==
==56456== LEAK SUMMARY:
==56456==    definitely lost: 30 bytes in 1 blocks
```

Address sanitizer (clang 3.9.0)

```
==57346==ERROR: LeakSanitizer: detected memory leaks

Direct leak of 30 byte(s) in 1 object(s) allocated from:
    #0 0x4e7e7b  (/home/schen/leanstl/tutorial/bin/list01err1asan+0x4e7e7b)
    #1 0x7fa4984c1e98  (/usr/lib/x86_64-linux-gnu/libstdc++.so.6+0xbee98)

SUMMARY: AddressSanitizer: 30 byte(s) leaked in 1 allocation(s).
```

Double mistake:

```cpp
  ~list()
  {
    // DOUBLY WRONG
    for (list_node_base* n = head_.next; n != &head_; n = n->next)
    {
      delete n;
    }
  }
```
Execrise: try memory checker with this double error.

### list01a: `list_node_base` with `protected` destructor

@i list01a.cc 11-39,68-70

TODO: Why not virtual dtor?

Site note: GCC [Bug 54812](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=54812)

```cpp
struct Base
{
 private:
  ~Base() = default;
};

int main()
{
  Base* p = new Base;
  delete p;
}
```

### More tests on T

## list02: copy control

## list03: iterator

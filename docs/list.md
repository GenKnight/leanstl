# Doubly Linked List: `list<T>`

![](list-tut.png)

## list00: data structure

![node](listnode.png)

Doubly linked list:
![list](list.png)

list00.cc:
```cpp
namespace leanstl
{

struct list_node_base
{
  list_node_base* next;
  list_node_base* prev;
};

template <typename T>
class list
{
 public:
  list()
  {
    head_.next = &head_;
    head_.prev = &head_;
  }

  // FIXME: change to private
  struct list_node : list_node_base
  {
    T value_;
  };

 private:
  list_node_base head_;
  size_t size_ = 0;
};

}  // namespace leanstl
```

Object sizes on 64-bit Linux.

```
sizeof void*:           8
sizeof size_t:          8
sizeof list_node_base: 16
sizeof list:           24

T = int
     sizeof T:          4
     sizeof list_node: 24

T = std::string
     sizeof T:          8
     sizeof list_node: 24

T = std::vector<int>
     sizeof T:         24
     sizeof list_node: 40
```

Object sizes on 32-bit Linux.

```
sizeof void*:           4
sizeof size_t:          4
sizeof list_node_base:  8
sizeof list:           12

T = int
     sizeof T:          4
     sizeof list_node: 12

T = std::string
     sizeof T:          4
     sizeof list_node: 12

T = std::vector<int>
     sizeof T:         12
     sizeof list_node: 20
```

## list01: destructor

```cpp
template <typename T>
class list
{
 public:
  list()
  {
    head_.next = &head_;
    head_.prev = &head_;
  }

  ~list()
  {
    for (list_node_base* n = head_.next; n != &head_;)
    {
      list_node* tod = static_cast<list_node*>(n);
      n = n->next;
      delete tod;
    }
  }

  list(const list& rhs) = delete;
  void operator=(const list& rhs) = delete;

  // Effective Modern C++, Item 41.
  void push_front(T x)
  {
    list_node* n = new list_node(std::move(x));
    n->next = head_.next;
    n->next->prev = n;
    head_.next = n;
    n->prev = &head_;
    size_++;
  }

  T& front()
  {
    return static_cast<list_node*>(head_.next)->value_;
  }

 private:
  struct list_node : list_node_base
  {
    T value_;
    list_node(T&& x) : value_(std::move(x)) {}
  };

  list_node_base head_;
  size_t size_ = 0;
};
```

### Mistake: use-after-free

list01err0.cc
```cpp
  ~list()
  {
    // WRONG: use-after-free
    for (list_node_base* n = head_.next; n != &head_; n = n->next)
    {
      delete static_cast<list_node*>(n);
    }
  }
```

```cpp
int main()
{
  leanstl::list<int> li;
  li.push_front(43);
  printf("front=%d\n", li.front());
}
```
```
$ code/bin/list01err0
front=43
Segmentation fault (core dumped)

$ gdb code/bin/list01err0 core
Core was generated by `code/bin/list01err0'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x0000000000400847 in leanstl::list<int>::~list (this=0x7ffd3dff5da0) at list01err0.cc:30
30          for (list_node_base* n = head_.next; n != &head_; n = n->next)

(gdb) p n
$1 = (leanstl::list_node_base *) 0x0

(gdb) p *this
$2 = {
  head_ = {
    next = 0x181e010,
    prev = 0x181e010
  },
  size_ = 1
}

(gdb) p *head_.next
$3 = {
  next = 0x0,
  prev = 0x7ffd3dff5da0
}
```

Some clever person finds a way to avoid coredump, by deleting from tail to head.

list01err0hack.cc
```cpp
  ~list()
  {
    // STILL WRONG: use-after-free
    for (list_node_base* n = head_.prev; n != &head_; n = n->prev)
    {
      delete static_cast<list_node*>(n);
    }
  }
```

Valgrind
```
==56399== Invalid read of size 8
==56399==    at 0x400847: leanstl::list<int>::~list() (list01err0.cc:30)
==56399==    by 0x4007C6: main (list01err0.cc:75)
==56399==  Address 0x5a02040 is 0 bytes inside a block of size 24 free'd
==56399==    at 0x4C2A360: operator delete(void*) (vg_replace_malloc.c:507)
==56399==    by 0x400842: leanstl::list<int>::~list() (list01err0.cc:32)
==56399==    by 0x4007C6: main (list01err0.cc:75)
```

Address sanitizer

```
$ bin/list01err0asan
front=43
=================================================================
==57074==ERROR: AddressSanitizer: heap-use-after-free on address 0x60300000efe0 at pc 0x400de5 bp 0x7ffe324e9ee0 sp 0x7ffe324e9ed8
READ of size 8 at 0x60300000efe0 thread T0
    #0 0x400de4 in leanstl::list<int>::~list() code/list01err0.cc:30
    #1 0x400c3f in main code/list01err0.cc:73
    #2 0x7f19eb9f7b44 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21b44)
    #3 0x400a78 (code/bin/list01err0asan+0x400a78)

0x60300000efe0 is located 0 bytes inside of 24-byte region [0x60300000efe0,0x60300000eff8)
freed by thread T0 here:
    #0 0x7f19ec5f8477 in operator delete(void*) (/usr/lib/x86_64-linux-gnu/libasan.so.1+0x55477)
    #1 0x400dc3 in leanstl::list<int>::~list() code/list01err0.cc:32
    #2 0x400c3f in main code/list01err0.cc:73
    #3 0x7f19eb9f7b44 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21b44)

previously allocated by thread T0 here:
    #0 0x7f19ec5f7fff in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.1+0x54fff)
    #1 0x400e34 in leanstl::list<int>::push_front(int) code/list01err0.cc:41
    #2 0x400bda in main code/list01err0.cc:72
    #3 0x7f19eb9f7b44 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21b44)

SUMMARY: AddressSanitizer: heap-use-after-free code/list01err0.cc:30 leanstl::list<int>::~list()
```

### Mistake: delete pointer of `list_node_base*`

list01err1.cc
```cpp
  ~list()
  {
    // WRONG: delete base pointer without virtual dtor
    for (list_node_base* n = head_.next; n != &head_;)
    {
      list_node_base* tod = n;
      n = n->next;
      delete tod;
    }
  }
```

TODO: quote standard on this undefined behavior.

Valgrind
```
==56456== HEAP SUMMARY:
==56456==     in use at exit: 30 bytes in 1 blocks
==56456==   total heap usage: 4 allocs, 3 frees, 102 bytes allocated
==56456==
==56456== LEAK SUMMARY:
==56456==    definitely lost: 30 bytes in 1 blocks
```

Address sanitizer (clang 3.9.0)

```
==57346==ERROR: LeakSanitizer: detected memory leaks

Direct leak of 30 byte(s) in 1 object(s) allocated from:
    #0 0x4e7e7b  (code/bin/list01err1asan+0x4e7e7b)
    #1 0x7fa4984c1e98  (/usr/lib/x86_64-linux-gnu/libstdc++.so.6+0xbee98)

SUMMARY: AddressSanitizer: 30 byte(s) leaked in 1 allocation(s).
```

Double mistake:

```cpp
  ~list()
  {
    // DOUBLY WRONG
    for (list_node_base* n = head_.next; n != &head_; n = n->next)
    {
      delete n;
    }
  }
```
Execrise: try memory checker with this double error.

### list01alt: `list_node_base` with `protected` destructor

```cpp
struct list_node_base
{
  list_node_base* next;
  list_node_base* prev;

  // prevent deleting a pointer of list_node_base* which actually points to a list_node<T>
  // GCC had bug https://gcc.gnu.org/bugzilla/show_bug.cgi?id=54812 on this, fixed in 4.9.0
 protected:
  ~list_node_base() = default;
};

template <typename T>
struct list_node : list_node_base
{
  T value_;
  list_node(T&& x) : value_(std::move(x)) {}
};

template <typename T>
class list
{
 public:
  list()
    : head_(0)
  {
    head_.next = &head_;
    head_.prev = &head_;
  }

 private:
  list_node<size_t> head_;  // size is head_.value_
};
```

TODO: Why not virtual dtor?

Site note: GCC [Bug 54812](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=54812)

```cpp
struct Base
{
 private:
  ~Base() = default;
};

int main()
{
  Base* p = new Base;
  delete p;
}
```

## list02: iterator

### list02const: `const_iterator`

## list03: copy control
